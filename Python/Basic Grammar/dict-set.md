### dict
[Python]()内置了字典： [dict]() 的支持，[dict]() 全称dictionary，在其他语言中也称为 [map]() ，使用键-值（key-value）存储，具有极快的查找速度。

举个例子，假设要根据同学的名字查找对应的成绩，如果用[list]()实现，需要两个[list]()：
```python
names = ['fmw', 'zhang', 'li']
scores = [95, 75, 85]
```
给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。

如果用 [dict]() 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个 [dict]() 如下：
```python
>>> d = {'fmw': 95, 'zhang': 75, 'li': 85}
>>> d['fmw']
95
```
把数据放入 [dict]() 的方法，除了初始化时指定外，还可以通过key放入：
```python
>>> d['zhang'] = 67
>>> d['zhang']
67
```
如果key不存在， [dict]() 就会报错：
```python
>>> d['song']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'song'
```
要避免key不存在的错误，有两种办法，一是通过 [in]() 判断key是否存在：
```python
>>> 'song' in d
False
```
二是通过 [dict]() 提供的 [get()]() 方法，如果key不存在，可以返回None，或者自己指定的value：
```python
>>> d.get('song')
>>> d.get('song', -1)
-1
```
> 注意：返回`None`的时候Python的交互环境不显示结果。
要删除一个key，用 [pop(key)]() 方法，对应的value也会从 [dict]() 中删除：
```python
>>> d.pop('zhang')
75
>>> d
{'fmw': 95, 'li': 85}
```
和 [list]() 比较，[dict]() 有以下几个特点：

   1. 查找和插入的速度极快，不会随着key的增加而变慢；
   1. 需要占用大量的内存，内存浪费多。
  
而 [list]() 相反：

   1. 查找和插入的时间随着元素的增加而增加；
   1. 占用空间小，浪费内存很少。
  
所以，[dict]()是用空间来换取时间的一种方法。
---
### set
[set]() 和 [dict]() 类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在 [set]() 中，没有重复的key。

要创建一个 [set]() ，需要提供一个[list]()作为输入集合：
```python
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}
```
注意，传入的参数[[1, 2, 3]]()是一个list，而显示的[{1, 2, 3}]()只是告诉你这个 [set]() 内部有1，2，3这3个元素，显示的顺序也不表示 [set]() 是有序的。。

重复元素在 [set]() 中自动被过滤：
```python
>>> s = set([1, 1, 2, 2, 3, 3])
>>> s
{1, 2, 3}
```
通过 [add(key)]() 方法可以添加元素到 [set]() 中，可以重复添加，但不会有效果：
```python
>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
```
通过 [remove(key)]() 方法可以删除元素：
```python
>>> s.remove(4)
>>> s
{1, 2, 3}
```
[set]() 可以看成数学意义上的无序和无重复元素的集合，因此，两个 [set]() 可以做数学意义上的交集、并集等操作：
```python
>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}
```
